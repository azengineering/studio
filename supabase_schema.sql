
-- Enable the citext extension for case-insensitive text
CREATE EXTENSION IF NOT EXISTS citext WITH SCHEMA public;

--
-- Create Tables
--

-- Users Table
CREATE TABLE IF NOT EXISTS public.users (
    id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
    email character varying NOT NULL,
    name character varying,
    gender public.citext,
    age integer,
    state public.citext,
    "mpConstituency" public.citext,
    "mlaConstituency" public.citext,
    panchayat public.citext,
    "createdAt" timestamp with time zone DEFAULT now(),
    "isBlocked" boolean DEFAULT false,
    "blockedUntil" timestamp with time zone,
    "blockReason" text
);

-- Leaders Table
CREATE TABLE IF NOT EXISTS public.leaders (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
    name public.citext NOT NULL,
    "partyName" public.citext,
    gender public.citext NOT NULL,
    age integer,
    "photoUrl" text,
    constituency public.citext NOT NULL,
    "nativeAddress" text,
    "electionType" public.citext NOT NULL,
    location jsonb,
    rating double precision DEFAULT 0 NOT NULL,
    "reviewCount" integer DEFAULT 0 NOT NULL,
    "previousElections" jsonb,
    "manifestoUrl" text,
    "twitterUrl" text,
    "addedByUserId" uuid REFERENCES public.users(id) ON DELETE SET NULL,
    "createdAt" timestamp with time zone DEFAULT now() NOT NULL,
    status public.citext DEFAULT 'pending'::public.citext NOT NULL,
    "adminComment" text
);

-- Ratings Table
CREATE TABLE IF NOT EXISTS public.ratings (
    "leaderId" uuid REFERENCES public.leaders(id) ON DELETE CASCADE NOT NULL,
    "userId" uuid REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,
    rating integer NOT NULL,
    comment text,
    "socialBehaviour" public.citext,
    "createdAt" timestamp with time zone DEFAULT now() NOT NULL,
    "updatedAt" timestamp with time zone DEFAULT now() NOT NULL,
    PRIMARY KEY ("leaderId", "userId")
);

-- Admin Messages Table
CREATE TABLE IF NOT EXISTS public.admin_messages (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,
    message text NOT NULL,
    "isRead" boolean DEFAULT false,
    "createdAt" timestamp with time zone DEFAULT now() NOT NULL
);

-- Site Settings Table
CREATE TABLE IF NOT EXISTS public.site_settings (
    id bigint PRIMARY KEY generated by default as identity,
    maintenance_active public.citext DEFAULT 'false',
    maintenance_start timestamp with time zone,
    maintenance_end timestamp with time zone,
    maintenance_message text,
    contact_email public.citext,
    contact_phone public.citext,
    contact_twitter text,
    contact_linkedin text,
    contact_youtube text,
    contact_facebook text
);
-- Ensure there's only one row for settings
INSERT INTO public.site_settings (id) VALUES (1) ON CONFLICT (id) DO NOTHING;


-- Notifications Table
CREATE TABLE IF NOT EXISTS public.notifications (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
    message text NOT NULL,
    "startTime" timestamp with time zone,
    "endTime" timestamp with time zone,
    "isActive" boolean DEFAULT true NOT NULL,
    "createdAt" timestamp with time zone DEFAULT now() NOT NULL,
    link text
);

-- Polls Tables
CREATE TABLE IF NOT EXISTS public.polls (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
    title text NOT NULL,
    description text,
    is_active boolean DEFAULT false NOT NULL,
    active_until timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);

CREATE TABLE IF NOT EXISTS public.poll_questions (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
    poll_id uuid REFERENCES public.polls(id) ON DELETE CASCADE NOT NULL,
    question_text text NOT NULL,
    question_type public.citext NOT NULL,
    question_order integer NOT NULL
);

CREATE TABLE IF NOT EXISTS public.poll_options (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
    question_id uuid REFERENCES public.poll_questions(id) ON DELETE CASCADE NOT NULL,
    option_text text NOT NULL,
    option_order integer NOT NULL
);

CREATE TABLE IF NOT EXISTS public.poll_responses (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
    poll_id uuid REFERENCES public.polls(id) ON DELETE CASCADE NOT NULL,
    question_id uuid REFERENCES public.poll_questions(id) ON DELETE CASCADE NOT NULL,
    option_id uuid REFERENCES public.poll_options(id) ON DELETE CASCADE NOT NULL,
    user_id uuid REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    UNIQUE(question_id, user_id)
);

-- Support Tickets Table
CREATE TABLE IF NOT EXISTS public.support_tickets (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid REFERENCES public.users(id) ON DELETE SET NULL,
    user_name text NOT NULL,
    user_email public.citext NOT NULL,
    subject text NOT NULL,
    message text NOT NULL,
    status public.citext DEFAULT 'open'::public.citext NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    resolved_at timestamp with time zone,
    admin_notes text
);


--
-- Enable RLS on all tables
--
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.leaders ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.ratings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.admin_messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.site_settings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.polls ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.poll_questions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.poll_options ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.poll_responses ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.support_tickets ENABLE ROW LEVEL SECURITY;

--
-- RLS Policies
--

-- users table policies
DROP POLICY IF EXISTS "Allow authenticated users to read any profile" ON public.users;
CREATE POLICY "Allow authenticated users to read any profile" ON public.users FOR SELECT TO authenticated USING (true);

DROP POLICY IF EXISTS "Allow users to update their own profile" ON public.users;
CREATE POLICY "Allow users to update their own profile" ON public.users FOR UPDATE TO authenticated USING (auth.uid() = id);

-- leaders table policies
DROP POLICY IF EXISTS "Allow public read access to approved leaders" ON public.leaders;
CREATE POLICY "Allow public read access to approved leaders" ON public.leaders FOR SELECT TO anon, authenticated USING (status = 'approved');

DROP POLICY IF EXISTS "Allow users to read their own pending/rejected leaders" ON public.leaders;
CREATE POLICY "Allow users to read their own pending/rejected leaders" ON public.leaders FOR SELECT TO authenticated USING (auth.uid() = "addedByUserId");

DROP POLICY IF EXISTS "Allow authenticated users to add new leaders" ON public.leaders;
CREATE POLICY "Allow authenticated users to add new leaders" ON public.leaders FOR INSERT TO authenticated WITH CHECK (true);

DROP POLICY IF EXISTS "Allow user to update their own submitted leader" ON public.leaders;
CREATE POLICY "Allow user to update their own submitted leader" ON public.leaders FOR UPDATE TO authenticated USING (auth.uid() = "addedByUserId");

-- ratings table policies
DROP POLICY IF EXISTS "Allow public read access to ratings" ON public.ratings;
CREATE POLICY "Allow public read access to ratings" ON public.ratings FOR SELECT TO anon, authenticated USING (true);

DROP POLICY IF EXISTS "Allow authenticated users to insert ratings" ON public.ratings;
CREATE POLICY "Allow authenticated users to insert ratings" ON public.ratings FOR INSERT TO authenticated WITH CHECK (auth.uid() = "userId");

DROP POLICY IF EXISTS "Allow users to update their own ratings" ON public.ratings;
CREATE POLICY "Allow users to update their own ratings" ON public.ratings FOR UPDATE TO authenticated USING (auth.uid() = "userId");

-- admin_messages table policies
DROP POLICY IF EXISTS "Allow user to read their own messages" ON public.admin_messages;
CREATE POLICY "Allow user to read their own messages" ON public.admin_messages FOR SELECT TO authenticated USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Allow user to mark their own messages as read" ON public.admin_messages;
CREATE POLICY "Allow user to mark their own messages as read" ON public.admin_messages FOR UPDATE TO authenticated USING (auth.uid() = user_id);

-- site_settings table policies
DROP POLICY IF EXISTS "Allow public read access to site settings" ON public.site_settings;
CREATE POLICY "Allow public read access to site settings" ON public.site_settings FOR SELECT TO anon, authenticated USING (true);

-- notifications table policies
DROP POLICY IF EXISTS "Allow public read access to notifications" ON public.notifications;
CREATE POLICY "Allow public read access to notifications" ON public.notifications FOR SELECT TO anon, authenticated USING (true);

-- polls tables policies
DROP POLICY IF EXISTS "Allow public read access to polls and their components" ON public.polls;
CREATE POLICY "Allow public read access to polls and their components" ON public.polls FOR SELECT TO anon, authenticated USING (true);

DROP POLICY IF EXISTS "Allow public read access to poll questions" ON public.poll_questions;
CREATE POLICY "Allow public read access to poll questions" ON public.poll_questions FOR SELECT TO anon, authenticated USING (true);

DROP POLICY IF EXISTS "Allow public read access to poll options" ON public.poll_options;
CREATE POLICY "Allow public read access to poll options" ON public.poll_options FOR SELECT TO anon, authenticated USING (true);

DROP POLICY IF EXISTS "Allow authenticated users to submit poll responses" ON public.poll_responses;
CREATE POLICY "Allow authenticated users to submit poll responses" ON public.poll_responses FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Allow users to view their own poll responses" ON public.poll_responses;
CREATE POLICY "Allow users to view their own poll responses" ON public.poll_responses FOR SELECT TO authenticated USING (auth.uid() = user_id);

-- support_tickets policies
DROP POLICY IF EXISTS "Allow users to create support tickets" ON public.support_tickets;
CREATE POLICY "Allow users to create support tickets" ON public.support_tickets FOR INSERT TO anon, authenticated WITH CHECK (true);


--
-- Database Functions
--

-- Function to handle new user signup
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  INSERT INTO public.users (id, email, name)
  VALUES (new.id, new.email, new.raw_user_meta_data->>'name');
  RETURN new;
END;
$$;

-- Trigger for new user signup
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Function to ensure user profile exists, for fixing old accounts
CREATE OR REPLACE FUNCTION public.ensure_user_profile_exists()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_user_id uuid := auth.uid();
    v_user_email text;
    v_user_name text;
BEGIN
    IF NOT EXISTS (SELECT 1 FROM public.users WHERE id = v_user_id) THEN
        -- Get email and name from auth.users
        SELECT email, raw_user_meta_data->>'name'
        INTO v_user_email, v_user_name
        FROM auth.users
        WHERE id = v_user_id;

        -- Insert into public.users
        INSERT INTO public.users (id, email, name)
        VALUES (v_user_id, v_user_email, v_user_name);
    END IF;
END;
$$;


-- Function to handle new/updated rating
CREATE OR REPLACE FUNCTION public.handle_new_rating(p_leader_id uuid, p_user_id uuid, p_rating integer, p_comment text, p_social_behaviour public.citext)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- Upsert the rating
  INSERT INTO public.ratings ("leaderId", "userId", rating, comment, "socialBehaviour", "createdAt", "updatedAt")
  VALUES (p_leader_id, p_user_id, p_rating, p_comment, p_social_behaviour, now(), now())
  ON CONFLICT ("leaderId", "userId")
  DO UPDATE SET
    rating = EXCLUDED.rating,
    comment = EXCLUDED.comment,
    "socialBehaviour" = EXCLUDED."socialBehaviour",
    "updatedAt" = now();

  -- Recalculate and update the leader's average rating and review count
  UPDATE public.leaders
  SET
    "reviewCount" = (SELECT count(*) FROM public.ratings WHERE "leaderId" = p_leader_id),
    rating = (SELECT avg(rating) FROM public.ratings WHERE "leaderId" = p_leader_id)
  WHERE id = p_leader_id;
END;
$$;

-- Function to handle rating deletion
CREATE OR REPLACE FUNCTION public.handle_rating_deletion(p_user_id uuid, p_leader_id uuid)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- Delete the rating
  DELETE FROM public.ratings
  WHERE "userId" = p_user_id AND "leaderId" = p_leader_id;

  -- Recalculate and update the leader's average rating and review count
  UPDATE public.leaders
  SET
    "reviewCount" = (SELECT count(*) FROM public.ratings WHERE "leaderId" = p_leader_id),
    rating = COALESCE((SELECT avg(rating) FROM public.ratings WHERE "leaderId" = p_leader_id), 0)
  WHERE id = p_leader_id;
END;
$$;

-- Function to get reviews for a leader
CREATE OR REPLACE FUNCTION public.get_reviews_for_leader(p_leader_id uuid)
RETURNS TABLE(
    "userName" text,
    rating int,
    comment text,
    "updatedAt" timestamptz,
    "socialBehaviour" public.citext
)
LANGUAGE sql
STABLE
AS $$
  SELECT
    u.name as "userName",
    r.rating,
    r.comment,
    r."updatedAt",
    r."socialBehaviour"
  FROM public.ratings r
  JOIN public.users u ON r."userId" = u.id
  WHERE r."leaderId" = p_leader_id
  ORDER BY r."updatedAt" DESC;
$$;

-- Function to get user activities
CREATE OR REPLACE FUNCTION public.get_user_activities(p_user_id uuid)
RETURNS TABLE (
    "leaderId" uuid,
    "leaderName" text,
    "leaderPhotoUrl" text,
    rating int,
    comment text,
    "updatedAt" timestamptz,
    leader jsonb,
    "socialBehaviour" public.citext,
    "userName" text
)
LANGUAGE sql
STABLE
AS $$
  SELECT
    r."leaderId",
    l.name as "leaderName",
    l."photoUrl" as "leaderPhotoUrl",
    r.rating,
    r.comment,
    r."updatedAt",
    row_to_json(l) as leader,
    r."socialBehaviour",
    u.name as "userName"
  FROM public.ratings r
  JOIN public.leaders l ON r."leaderId" = l.id
  JOIN public.users u ON r."userId" = u.id
  WHERE r."userId" = p_user_id
  ORDER BY r."updatedAt" DESC;
$$;

-- Function to get all user activities (for admin)
CREATE OR REPLACE FUNCTION public.get_all_activities()
RETURNS TABLE (
    "leaderId" uuid,
    "leaderName" text,
    "leaderPhotoUrl" text,
    rating int,
    comment text,
    "updatedAt" timestamptz,
    leader jsonb,
    "socialBehaviour" public.citext,
    "userName" text
)
LANGUAGE sql
STABLE
SECURITY DEFINER
AS $$
  SELECT
    r."leaderId",
    l.name as "leaderName",
    l."photoUrl" as "leaderPhotoUrl",
    r.rating,
    r.comment,
    r."updatedAt",
    row_to_json(l) as leader,
    r."socialBehaviour",
    u.name as "userName"
  FROM public.ratings r
  JOIN public.leaders l ON r."leaderId" = l.id
  JOIN public.users u ON r."userId" = u.id
  ORDER BY r."updatedAt" DESC;
$$;


-- Function to get admin polls with response counts
CREATE OR REPLACE FUNCTION public.get_admin_polls()
RETURNS TABLE (
    id uuid,
    title text,
    is_active boolean,
    active_until timestamptz,
    created_at timestamptz,
    response_count bigint,
    is_promoted boolean
)
LANGUAGE sql
STABLE
SECURITY DEFINER
AS $$
    SELECT
        p.id,
        p.title,
        p.is_active,
        p.active_until,
        p.created_at,
        (SELECT COUNT(DISTINCT pr.user_id) FROM public.poll_responses pr WHERE pr.poll_id = p.id) as response_count,
        EXISTS (SELECT 1 FROM public.notifications n WHERE n.link = '/polls/' || p.id::text) as is_promoted
    FROM
        public.polls p
    ORDER BY
        p.created_at DESC;
$$;

-- Function to get poll results (for admin)
CREATE OR REPLACE FUNCTION public.get_poll_results(p_poll_id uuid)
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    result json;
BEGIN
    SELECT json_build_object(
        'pollTitle', p.title,
        'totalResponses', (SELECT COUNT(DISTINCT user_id) FROM poll_responses WHERE poll_id = p_poll_id),
        'genderDistribution', (
            SELECT json_agg(json_build_object('name', COALESCE(u.gender, 'Unknown'), 'value', COUNT(*)))
            FROM poll_responses pr
            JOIN users u ON pr.user_id = u.id
            WHERE pr.poll_id = p_poll_id
            GROUP BY u.gender
        ),
        'questions', (
            SELECT json_agg(
                json_build_object(
                    'id', q.id,
                    'text', q.question_text,
                    'answers', (
                        SELECT json_agg(
                            json_build_object('name', o.option_text, 'value', COUNT(r.id))
                        )
                        FROM poll_options o
                        LEFT JOIN poll_responses r ON o.id = r.option_id
                        WHERE o.question_id = q.id
                        GROUP BY o.option_text
                    )
                )
            )
            FROM poll_questions q
            WHERE q.poll_id = p_poll_id
        )
    )
    INTO result
    FROM polls p
    WHERE p.id = p_poll_id;

    RETURN result;
END;
$$;

-- Function to get active polls for a user
CREATE OR REPLACE FUNCTION public.get_active_polls_for_user(p_user_id uuid)
RETURNS TABLE (
    id uuid,
    title text,
    description text,
    is_active boolean,
    active_until timestamptz,
    created_at timestamptz,
    response_count bigint,
    user_has_voted boolean,
    is_promoted boolean
)
LANGUAGE sql
STABLE
AS $$
    SELECT
        p.id,
        p.title,
        p.description,
        p.is_active,
        p.active_until,
        p.created_at,
        (SELECT COUNT(DISTINCT pr.user_id) FROM public.poll_responses pr WHERE pr.poll_id = p.id) as response_count,
        EXISTS (SELECT 1 FROM public.poll_responses pr WHERE pr.poll_id = p.id AND pr.user_id = p_user_id) as user_has_voted,
        EXISTS (SELECT 1 FROM public.notifications n WHERE n.link = '/polls/' || p.id::text) as is_promoted
    FROM
        public.polls p
    WHERE
        p.is_active = true AND (p.active_until IS NULL OR p.active_until > now())
    ORDER BY
        p.created_at DESC;
$$;

-- Function to upsert a poll with questions and options
CREATE OR REPLACE FUNCTION public.upsert_poll(poll_data jsonb)
RETURNS uuid
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_poll_id uuid;
    q_data jsonb;
    o_data jsonb;
    v_question_id uuid;
    existing_question_ids uuid[];
    existing_option_ids uuid[];
BEGIN
    -- Upsert poll
    IF poll_data ? 'id' AND poll_data->>'id' != '' THEN
        v_poll_id := (poll_data->>'id')::uuid;
        UPDATE polls SET
            title = poll_data->>'title',
            description = poll_data->>'description',
            is_active = (poll_data->>'is_active')::boolean,
            active_until = (poll_data->>'active_until')::timestamptz
        WHERE id = v_poll_id;
    ELSE
        INSERT INTO polls (title, description, is_active, active_until)
        VALUES (
            poll_data->>'title',
            poll_data->>'description',
            (poll_data->>'is_active')::boolean,
            (poll_data->>'active_until')::timestamptz
        ) RETURNING id INTO v_poll_id;
    END IF;

    -- Get existing question and option IDs to remove orphans
    SELECT array_agg(id) INTO existing_question_ids FROM poll_questions WHERE poll_id = v_poll_id;

    IF array_length(existing_question_ids, 1) > 0 THEN
      SELECT array_agg(id) INTO existing_option_ids FROM poll_options WHERE question_id = ANY(existing_question_ids);
    END IF;

    -- Upsert questions
    FOR q_data IN SELECT * FROM jsonb_array_elements(poll_data->'questions')
    LOOP
        IF q_data ? 'id' AND q_data->>'id' != '' THEN
            v_question_id := (q_data->>'id')::uuid;
            UPDATE poll_questions SET
                question_text = q_data->>'question_text',
                question_type = (q_data->>'question_type')::public.citext,
                question_order = (q_data->>'question_order')::int
            WHERE id = v_question_id;
        ELSE
            INSERT INTO poll_questions (poll_id, question_text, question_type, question_order)
            VALUES (
                v_poll_id,
                q_data->>'question_text',
                (q_data->>'question_type')::public.citext,
                (q_data->>'question_order')::int
            ) RETURNING id INTO v_question_id;
        END IF;

        -- Remove current question ID from the list of candidates for deletion
        existing_question_ids := array_remove(existing_question_ids, v_question_id);

        -- Upsert options
        FOR o_data IN SELECT * FROM jsonb_array_elements(q_data->'options')
        LOOP
            IF o_data ? 'id' AND o_data->>'id' != '' THEN
                UPDATE poll_options SET
                    option_text = o_data->>'option_text',
                    option_order = (o_data->>'option_order')::int
                WHERE id = (o_data->>'id')::uuid;
                existing_option_ids := array_remove(existing_option_ids, (o_data->>'id')::uuid);
            ELSE
                INSERT INTO poll_options (question_id, option_text, option_order)
                VALUES (
                    v_question_id,
                    o_data->>'option_text',
                    (o_data->>'option_order')::int
                );
            END IF;
        END LOOP;
    END LOOP;

    -- Delete orphaned questions and options
    IF array_length(existing_question_ids, 1) > 0 THEN
      DELETE FROM poll_questions WHERE id = ANY(existing_question_ids);
    END IF;
     IF array_length(existing_option_ids, 1) > 0 THEN
      DELETE FROM poll_options WHERE id = ANY(existing_option_ids);
    END IF;

    RETURN v_poll_id;
END;
$$;


-- Function to submit a poll response
CREATE OR REPLACE FUNCTION public.submit_poll_response(p_poll_id uuid, p_user_id uuid, p_answers jsonb)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    answer jsonb;
BEGIN
    IF EXISTS (SELECT 1 FROM poll_responses WHERE poll_id = p_poll_id AND user_id = p_user_id) THEN
        RAISE EXCEPTION 'User has already voted in this poll.';
    END IF;

    FOR answer IN SELECT * FROM jsonb_array_elements(p_answers)
    LOOP
        INSERT INTO poll_responses (poll_id, question_id, option_id, user_id)
        VALUES (
            p_poll_id,
            (answer->>'questionId')::uuid,
            (answer->>'optionId')::uuid,
            p_user_id
        );
    END LOOP;
END;
$$;


-- Function to get ticket statistics
CREATE OR REPLACE FUNCTION public.get_ticket_stats()
RETURNS TABLE(total bigint, open bigint, in_progress bigint, resolved bigint, closed bigint, avg_resolution_hours numeric)
LANGUAGE sql
STABLE
SECURITY DEFINER
AS $$
    SELECT
        COUNT(*) AS total,
        COUNT(*) FILTER (WHERE status = 'open') AS open,
        COUNT(*) FILTER (WHERE status = 'in-progress') AS in_progress,
        COUNT(*) FILTER (WHERE status = 'resolved') AS resolved,
        COUNT(*) FILTER (WHERE status = 'closed') AS closed,
        EXTRACT(EPOCH FROM AVG(resolved_at - created_at)) / 3600 AS avg_resolution_hours
    FROM public.support_tickets;
$$;


--
-- Grant permissions on functions
--
GRANT EXECUTE ON FUNCTION public.handle_new_rating(uuid, uuid, integer, text, public.citext) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_reviews_for_leader(uuid) TO anon, authenticated;
GRANT EXECUTE ON FUNCTION public.get_user_activities(uuid) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_active_polls_for_user(uuid) TO anon, authenticated;
GRANT EXECUTE ON FUNCTION public.submit_poll_response(uuid, uuid, jsonb) TO authenticated;
GRANT EXECUTE ON FUNCTION public.ensure_user_profile_exists() TO authenticated;

